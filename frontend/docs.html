<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Chrome Symbolizer - Documentation</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" media="screen" href="/static/style.css" />
    <style>
      h2 {
        border-bottom: 1px solid #BBB;
      }
    </style>
    <script>
      function toggleHidden(a, name) {
        var elm = document.getElementById(name);
        var hidden = elm.hidden;
        elm.hidden = !hidden;
        if (hidden) {
          a.innerText = 'Hide';
        } else {
          a.innerText = 'Show';
        }
        return false;
      }
    </script>
  </head>
  <body>
    <h1>Chrome Symbolizer Documentation</h1>

    <p>
      The Chrome Symbolizer (crsym) is a tool that helps Chrome developers
      symbolize stack fragments and non-Breakpad crash reports. Rather than
      requiring developers to use platform-specific symbol files on a local
      machine, this takes advantage of having access to the Breakpad symbol
      data used for processing most Chrome crash reports.
    </p>

    <h2>Interface Overview</h2>
    <p>
      The Symbolizer accepts various input types, some of which require
      different pieces of data than others in order to symbolize. The
      <strong>Input Type</strong> controls what is going to be symbolized.
      Type-specific fields are covered below.
    </p>
    <p>
      Below the type inputs are three tabbed sections: <strong>Input</strong>,
      <strong>Output</strong>, and <strong>Scratch</strong>. Each one of these
      sections is a text area. The <strong>Input</strong> section is where the
      data to be symbolized should be pasted. After the data is pasted here and
      the <strong>Symbolize</strong> button is pressed, the result of
      symbolization will be placed in the <strong>Output</strong> tab. The
      <strong>Scratch</strong> tab is unchanged through this process. It's a
      workpad on which developers can temporarily store results of
      symbolization. This is useful if the input being symbolized contains
      addresses from multiple modules and the developer wants both to be
      symbolized.
    </p>

    <h2>Crash Report Key</h2>
    <p>
      It's common in Chrome to place the stacktrace of an event into a key
      in a crash report, such that when a crash happens, some additional
      debugging data is present to track down the inconcistent state
      that led to the crash.
    </p>
    <p>
      These keys do not show up as a normal thread in the stack trace on the
      crash server, but instead are presented as metadata at the top of the
      crash report. For example <code>zombie_dealloc_bt</code> is used on
      Mac OS X to store the stacktrace of a deallocating object, so if it is
      used after that, it's possible to see when it was destroyed.
    </p>
    <p>
      To symbolize these crash keys, select the <strong>Crash Report
      Key</strong> input type and fill in the two fields:
    </p>
    <dl>
      <dt><strong>Crash Report ID</strong>:</dt>
      <dd>
        The unique identifier for the crash report. Users can provide this from
        <code>chrome://crashes</code>, or one can be found on the crash server.
      </dd>


    <h2>Look Up Module Information</h2>
    <p>
      If you want to look up information about the Chrome-related modules for
      a given version, you can use this input type. This can be useful for
      symbolizing stack fragments (see below).
    </p>
    <dl>
      <dt><strong>Product Name</strong>:</dt>
      <dd>
        The crash reporting product name. This is "Chrome" for Windows,
        Chrome_Mac on Mac, etc.
      </dd>
      <dt><strong>Product Version</strong>:</dt>
      <dd>
        The version for which you want to look up module information.
      </dd>
    </dl>

    <h2>Stack Fragments</h2>
    <p>
      The &ldquo;Stack Fragment&rdquo; accepts whitespace-separated addresses
      and outputs each address on its own line, along with any symbol and
      file/line information.
    </p>
    <p>
      Stack fragments contain no information about the code modules of the
      addresses being symbolized. Therefore, the developer must provide these
      pieces of data in order to look up the symbol information. The three
      pieces are:
    </p>
    <dl>
      <dt><a name="fragment_name"><strong>Module Name</strong></a>:</dt>
      <dd>
        The code module name, which is often the last path component of an
        archive, for example &ldquo;chrome.dll&rdquo; or &ldquo;Google Chrome
        Framework&rdquo;.
      </dd>

      <dt>
        <a name="fragment_identifier"><strong>Module Identifier</strong></a>:
      </dt>
      <dd>
        A unique identifier for the module. Rather than using version numbers,
        which are not guaranteed to be unique, the Breakpad crash servers use
        a 33-character long identifier, based on the UUID of the symbol file
        for the module.
      </dd>

      <dt>
        <a name="fragment_load_address"><strong>Base Address</strong></a>:
      </dt>
      <dd>
        The base address where the code module was mapped into memory. The
        symbolizer will subtract this from each of the addresses to find
        the function in the module. If the addresses being symbolized are
        absolute within the module, <code>0x0</code> is an acceptable value.
      </dd>
    </dl>

    <h3>Finding the Module Information Locally</h3>
    <p>
      One way to locate the module name and identifier for an archive is to use
      the Breakpad <code>dump_syms</code> tool, which prints the module
      information as the first line of its output:
    </p>
    <pre class="code">
$ /Volumes/Source/chrome/src/out/Release/dump_syms /Applications/Google\ Chrome.app/Contents/Versions/21.0.1171.0/Google\ Chrome\ Framework.framework/Google\ Chrome\ Framework | head -1
MODULE mac x86 CDF1AAB2EE0FEAF1A28EB28A65615FDC0 Google Chrome Framework</pre>
    <p>
      The line of output contains the platform (&ldquo;mac&rdquo;), the
      architecture (&ldquo;x86&rdquo;), the identifier
      (&ldquo;CDF1AAB2EE0FEAF1A28EB28A65615FDC0&rdquo;), and the module name
      (&ldquo;Google Chrome Framework&rdquo;).
    </p>


    <h2>Apple Crash Report</h2>
    <p>
      Some crashes are not caught by Breakpad, but Mac OS X will still generate
      a crash report file. These are stored in
      <code>~/Library/Logs/CrashReporter</code> and users attach the files to
      bugs. To symbolize an Apple Crash Report, set the <strong>Input
      Type</strong> and then paste the entire crash report into the
      <strong>Input</strong> field. Make sure that the crash report contains a
      &ldquo;Binary Images&rdquo; so that crsym can find the appropriate symbol
      files.
    </p>

    <h2>Android Log</h2>
    <p>
      A crash in the Android version of chrome triggers a series of output to the
      android log.  The android log records the unsymbolized stack trace of the
      crash.  For official release builds, the version ID of the build is also
      printed.   Using this version ID, crsym can retrieve the associated chrome
      module and symbolize the trace for the chrome crash.  To use this feature,
      select <strong>Android</strong> in tabs, copy and paste your android log
      (from <code>adb logcat</code>) into the <strong>Input</strong> textbox,
      and press the <strong>Symbolize</strong> button.  The user can optionally
      provide a version ID by entering the ID in the <strong>Android Chrome Version
      </strong> field.  If the log also contains a version ID, then the manually
      entered ID supersedes the one found in the log.
    </p>

  </body>
</html>
